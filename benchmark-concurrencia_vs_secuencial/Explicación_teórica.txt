Explicación teórica de los resultados obtenidos en la computación de las simulaciones en códigos secuenciales y concurrentes.

En la simulación física planteada, cada cuerpo ejerce una fuerza gravitacional sobre todos los demás. Este tipo de problema presenta una complejidad de orden cuadrático O(n2), ya que en cada paso de tiempo deben calcularse todas las interacciones posibles entre pares de cuerpos. Se desarrollaron dos implementaciones de esta simulación: una versión secuencial y otra concurrente utilizando goroutines y canales en Go. A través de pruebas de rendimiento se observó que, en este caso particular, la versión secuencial resulta más eficiente tanto en tiempo de ejecución como en uso de memoria.

La implementación secuencial calcula todas las interacciones en un único hilo de ejecución, sin estructuras intermedias ni coordinación entre procesos. De esta forma, aprovecha al máximo la memoria local y mantiene un flujo de ejecución simple y directo. Esto reduce la sobrecarga y permite una ejecución predecible, incluso con un número considerable de cuerpos.

En contraste, la versión concurrente representa cada cuerpo como una goroutine independiente, que se comunica con las demás mediante canales para recibir las fuerzas externas. Aunque esta estructura es conceptualmente atractiva desde el punto de vista de la concurrencia, en la práctica introduce un costo significativo. La principal razón es que cada cuerpo debe enviar y recibir una cantidad muy elevada de mensajes en cada paso de la simulación, lo que genera una sobrecarga de comunicación. Además, cada cuerpo debe esperar a que todos los demás completen sus operaciones antes de avanzar, lo que introduce sincronización implícita y bloqueos. A esto se suma el costo adicional de crear y mantener miles de goroutines y canales, lo que incrementa el uso de memoria y de ciclos de CPU destinados al control en lugar del cálculo físico propiamente dicho.

La concurrencia en esta simulación no aporta una mejora de rendimiento, ya que las tareas no son verdaderamente independientes. Todos los cuerpos requieren información actualizada de todos los demás para poder continuar, lo que impide dividir el trabajo en unidades que se puedan ejecutar de manera autónoma o en paralelo efectiva. En este contexto, el modelo de concurrencia agrega más complejidad y trabajo al sistema del que logra ahorrar, resultando en una ejecución más lenta y menos eficiente.

En conclusión, para esta simulación de cuerpos altamente interdependientes, la versión secuencial es superior a la concurrente en términos de eficiencia. La concurrencia introduce costos significativos en coordinación y comunicación que no se ven compensados por una mejora en el tiempo de cálculo. Sin embargo, en problemas con menor dependencia entre elementos o en simulaciones distribuidas espacialmente, la concurrencia sigue siendo una herramienta valiosa para mejorar el rendimiento.
